Einleitung
==========

Das vorliegende Dokument beschreibt die Entwicklung eines Frameworks,
welches es erlaubt verschiedene Anwendungen im öffentlichen Raum zu
installieren, die mit Hilfe von mobilen Controllern gesteuert werden
können. Hierbei stehen zwei Aspekte im Vordergrund. Zum einen soll das
Framework eine Schnittstelle bieten, eigene Anwendungen unkompliziert in
eine stabile Infrastruktur einzubinden. Dies bedeutet, dass alle
notwendigen Funktionen der Kommunikation und der Nutzerverwaltung durch
das Framework abgedeckt sind und der Entwickler unabhängig davon sehr
flexible verschiedenste Anwendungen realisieren kann. Zum anderen soll
das Framework dem Endbenutzer die einfache Bedienung der Anwendung über
persönliche mobile Geräte, wie Smartphones ermöglichen. Hierbei sollen
möglichst alle Arten der Eingabe des Endgerätes genutzt und dieses so in
ein multifunktionales Gamepad verwandelt werden.

Problemstellung
---------------

#### Problemstellung

\
Die Möglichkeit ein Spiel komfortabel mit einem mobilen Gerät zu
verbinden und zu steuern soll im folgenden unseren Beschreibungen
zugrunde liegen. Hierzu werden verschiedene Technologien miteinander
verbunden und genutzt.\
Eine Möglichkeit zu schaffen komfortabel an einem Spiel teilzunehmen,
als Beispiel an einem Flughafen per QR-Code einem laufenden Spiel
beizutreten, motivierte uns zu diesem Thema.

Methodik
========

Projektmanagement
-----------------

Das Team besteht aus 5 Projektmitgliedern. Die Verteilung der Aufgaben
ist in Tabelle \[table:Aufgabenverteilung\] aufgestellt. Verschiedene
Aufgaben sind im Gitlab erfasst und Personen zugewiesen. Ein
wöchentliches persönliches Treffen aller Projektmitglieder führt zu
einer guten Arbeitsmoral und hohen Effektivität.

### GitLab

Das Projekt wurde auf einem eigenen GitLab gehostet und den
Projektmitgliedern zur Verfügung gestellt. Die Issues des Systems wurden
genutzt um Aufgaben zu verteilen und zu dokumentieren.\
Strukuriert wurde das Arbeiten nach Feature Branches, um das Arbeiten am
Projekt möglichst flexibel zu halten. Der Master-Branch diente als
Release-Branch, in den regelmäßig die Änderungen per Merge Request
eingetragen und getestet wurden.

\[table:Aufgabenverteilung\]

<span>| L<span>2.6cm</span> | C<span>2cm</span> | C<span>2cm</span> |
C<span>2cm</span> | C<span>2cm</span> | C<span>2cm</span> |</span> & & &
& &\
Recherche & X & X & X & X & X\
Konzept & X & X & X & X & X\
Serverdesign & & X & & & X\
Networking & & X & & X & X\
GameAPI & & X & & & X\
DemoGame & X & & & & X\
ClientFrontend & X & & X & &\
ClientBackend & X & & X & &\
Database & & & & X &\
Poster & & & & &\
Documentation & & & & & X\
Projektmgmt. & & & & & X\

Technologien
------------

\[t\]<span>0.4</span>

#### NodeJS / Javascript

\
NodeJS ist eine Laufzeitumgebung für JavaScript und basiert auf der
Chrome’s V8 JavaScript engine.

\[t\]<span>0.5</span>

#### HTML 5

\
In diesem Projekt setzen wir auf HTML5 um die Sensordaten der Geräte
auszulesen. Dies ist durch das neue HTML5 einfach umzusetzen.

### Javascript Bibliotheken

\[t\]<span>0.4</span>

#### jQuery

\
jQuery ist ein schnelle, umfangreiche und einfach zu bedienende
JavaScript-Bibliothek. Sie ermöglicht Dinge wie das einfache
modifizieren von HTML, Ereignisverarbeitung, Animation und Ajax.

\[t\]<span>0.5</span>

#### require.js

\
RequireJS ist eine Bibliothek um einfach JavaScript-Dateien und Module
zu laden. Es ist für den In-Browser-Einsatz optimiert, kann allerdings
auch in anderen JavaScript-Umgebungen wie Rhino und Note verwendet
werden.

\[t\]<span>0.4</span>

#### socket.io

\
Das Framework “socket.io” wird in Abschitt \[socketio\] ausführlich
beschrieben.

\[t\]<span>0.5</span>

#### MongoDB

\
MongoDB ist eine Schema-freie, dokumentenorientierte
Open-Source-Datenbank, die in der Programmiersprache C++ geschrieben
ist. Da die Datenbank dokumentenorientiert ist, kann sie Sammlungen von
JSON-ähnlichen Dokumenten verwalten. Dadurch lässt sie sich leicht mit
JavaScript zusammen benutzen und wurde von uns gewählt.

### Hardware

Die Server Hardware kann je nach Bedarf eine Server- oder
Desktopumgebung sein. Der NodeJS Server kann platformunabhängig auf so
gut wie allen Platformen genutzt werden.\
Als Eingabegerät sind Mobile Geräte wie Smartphones oder Tablets
angedacht. Mit ihren Sensoren und Touchdisplays sind diese
prädestiniert.

Implementierung
===============

Architektur
-----------

\[t\]<span>0.4</span>

#### Network

\
Die Netzwerkverbindungen bilden einen wichtigen Bestandteil der
Anwendung. Alle Clients und das Server-Frontend bzw. Spiel verbinden
sich zum Server via WebSocket.

\[t\]<span>0.5</span>

![Architektur der Applikation<span
data-label="fig:test2"></span>](images/arch/M113.png){width="8.5cm"}

### socket.io {#socketio}

Zum Aufbau und Handling der Netzwerkverbindungen wird die Bibliothek
socket.io von Guillermo Rauch verwendet. Sie kapselt die WebSocket API
Spezifikationen und bietet eine vereinfachte und einfach zu benutzende
API zu den WebSockets auf Client und Server-Seite. Außerdem verfügt sie
über Failover-Strategien, die das Verwenden von anderen Protokollen
vorsehen, für den Fall, dass WebSockets vom Client oder Server nicht
unterstützt werden.\
Auf node Server Seite werden die Pakete ’http’ und ’socket.io’ benötigt.
Erstes um einen HTTP-Server zu erstellen und letzteres, um diesen dann
zu einer WebSocket Verbindung aufzuwerten und diese dann zu verwalten.
Grundlegen wird die Verbindung mit Hilfe von message Events
implementiert, welche auf dem jeweiligen Socket ausgelöst und abgehört
werden können. Dieses Prinzip ähnelt stark den von node bekannten
Events. Eine Client-Version von socket.io wird vom Server automatisch
veröffentlich und kann so auf dem Client direkt eingebunden und
verwendet werden.[^1]

### Server Network Handling

Die Anwendung besteht aus einem zentralen node Server, einem Frontend
zur Darstellung des Spiels und eine unbestimmte Anzahl an mobilen
Clients. Alle Komponenten stellen jeweils eine WebSocket Verbindung zum
Server her, der diese so zentral verwalten kann. Durch die
Implementation der selbst geschriebenen Module ’gameApi’ und
’clientNetwork’ werden die Funktionen der WebSockets erneut gekapselt
und ermöglichen eine stark angepasste Verwendung.\
Der Server hält zu jeder Zeit eine Liste aller offenen
Socket-Verbindungen, was es ermöglich individuell mit jedem Client und
dem Frontend zu kommunizieren und eingehende Nachrichten direkt einem
Absender zuzuordnen. Auf diesem Level der Kommunikation wurden
grundlegende Socket-Events zum Verbindungsaufbau, der Nutzerverwaltung
sowie dem Verschicken der eigentlichen Nachrichten implementiert.
Abhängig vom Typ der eingehenden Nachricht werden die Funktionen der
nächst-höheren Programmschicht aufgerufen, die diese dem Netzwerk Modul
bei der Initialisierung per Callback übergeben hat. Die eigentlichen
Socket-Events werden an dieser Stelle nicht weitergegeben, um die
technische Socket-Logik komplett im Modul zu kapseln. Die Struktur der
einzelnen Nachrichtentypen wurde genau definiert. Besonders im Fall der
tatsächlichen Nachtrichten Pakete wurde ein weiteres ’type’ Attribut
eingefügt, die es dem Spieleentwickler erlaubt unabhängig von den Socket
Events eigene Nachrichten-Typen zu definieren. Ein weiterer wichtiger
Aspekt ist die Art und Weise in der die Sockets auf Client-Seite
aufgebaut werden.\
Zusätzlich bietet das ’serverNetwork’ Modul eine Reihe an Funktionen an,
mit den Clients und dem Frontend zu kommunizieren und diese zu verwalten
@js-object2pages,@js-persistencewebsockets .

Session
-------

Die nächste Schicht nach dem Netzwerk stellt auf Server-Seite das Modul
’sessionHandling’ dar. Hier werden die noch anonymen Socket-Verbindungen
bzw. deren IDs mit tatsächlichen Nutzernamen und der zugrundeliegenden
Nutzerverwaltung verknüpft. Dies bedeutet zunächst, dass jeder Client
sich zum Benutzen der Anwendung am Server authentifizieren muss. Jede
eingehende Login-Anfrage wird an das Modul ’UserManagement’
weitergeleitet um die übergebenden Nutzerdaten zu verifizieren. Nach
einem erfolgreichen Login werden die Daten des Nutzers in eine Liste
aktiver Nutzer gespeichert und sein Nutzername wird an die nächste
Schicht weiter gegeben. Beim Disconnet eines Nutzers wird sein Eintrag
aus der Liste gelöscht und es wird ebenfalls eine Nachricht an die
nächste Programm-Schicht übergeben. Alle Nachrichten, die tatsächliche
Kommunikationsdaten beinhalten werden direkt weitergegeben.\
Ein Login bedeutet notwendigerweise eine zuvor erfolgte Registrierung,
welche ebenfalls vom ’UserManagement’ Modul verwaltet wird. Um die
Registrierung jedoch nicht zu einer unnötigen Barriere in der Verwendung
der Applikation zu machen, ist es ebenfalls möglich sich anonym
einzuloggen. In diesem Fall wird der jeweiligen Socket-Verbindung ein
zufälliger Nutzername zugewiesen. Der Vorteil eines Nutzerkontos bietet
die Möglichkeit für das Spiel, Session übergreifend Daten für die
Benutzer zu speichern.\
Die Login-Sessions sind direkt an eine bestehende Socket-Verbindung
gekoppelt und werden beendet, sobald der Socket geschlossen wird.

User Management
---------------

Das “UserManagement” kümmert sich um die Verwaltung der Nutzer. Dafür
stellt es Funktionen für die Registrierung, Authentifizierung sowie für
das setzen und holen von Benutzerdaten zur Verfügung. Die Funktionen im
“UserManagement” bekommen eine callback Funktion übergeben, welche bei
einer erfolgreichen Ausführung ausgeführt wird.

Datenbank
---------

Das “Database” Modul kümmert sich um die Persistente Speicherung aller
anfallenden Daten. Dafür wird eine MongoDB verwendete und die für das
hinzufügen, löschen, updaten und für Abfragen benötigten Funktionen zur
Verfügung gestellt.

Mobile - Sensoren und Daten
---------------------------

Die Basis aller weiteren Schritte ist das Auslesen der Sensordaten eines
geeigneten Gerätes, während der gesamten Entwicklung wurden hierfür
Smartphones unterschiedlicher Hersteller und Generationen verwenden. Die
Daten wurden auf dem Gerät gemessen, aufbereitet und als gekapselte
Datenpakete an den vorgesehenen Empfänger gesandt. Die Datenaufbereitung
ist ein wichtiger Schritt, um die Netzwerklast am Knotenpunkt, dem
Server, möglichst gering zu halten, da mehrere Geräte gleichzeitig eine
Verbindung herstellen und aufrecht erhalten können und dies zu einer
Überlast des Empfängers bei unkontrolliertem Sendevolumen führt.\
Die von der Applikation genutzten Daten sind im folgenden erläutert.

#### Touchbildschirm

Die übliche Art der Interaktion mit einem aktuellen Smartphone, die
Toucheingabe, darf natürlich nicht außer Acht gelassen werden. Da diese
in der Entwicklung äußerst einfach zu implementieren ist, unteranderem
über JQuerys .tap(), kann diese Eingabe als trivial angesehen und hier
nicht weiter darauf eingegangen werden.

#### Rotations- und Beschleunigungssensor

\
Diese Werte bilden den Kern der Applikation und sollen hier näher
dargestellt werden:\
Die Interaktion über die Bewegung des Smartphones im dreidimensionalen
Raum ist intuitiv und gut für jede denkbare Aufgabe geeignet. Die
Datenerhebung erfolgt dabei für gewöhnlich durch
Differentialkondensatoren und Drei-Achsen-Gyroskope. Da die Daten vom
Gerät kontinuierlich in festgelegten Intervallen bestimmt werden, können
diese auf komfortable Art und Weise ausgelesen werden. Die aufwändigere
Arbeit ist die anschließende Verarbeitung und Filterung der Daten. Dies
geschieht über ein zu setzendes Event, namentlich das “devicemotion”
-Event, das bei jeder Änderung der Rotation oder Beschleunigung feuert
und seine Daten beispielhaft in der Form event.acceleration.x; oder
event.accelerationRate.alpha; bereitstellt, ebenso wie das Intervall der
gemessenen Daten (in Millisekunden) über event.interval; verwendet
werden kann. Siehe auch Anhang \[rotation\].\
Die Originalversion der Rotation und Berechnungen sind zu finden in den
Aufzeichnungen von Damian Gordon[^2].\
Die Aufbereitung der Daten geschieht über eine Filterung aller leeren
und ungültigen Daten, außerdem aller Daten, die darauf schließen lassen,
dass keine Bewegung stattfand. Um eine Überlast der Datenverbindung zu
verhindern wird eine Mittelung der ausgelesenen Daten als adäquates
Mittel angesehen, diese kann über eine festgelegte Anzahl der Werte
vorgenommen werden. Da Smartphones allerdings in einem unterschiedlichen
Intervall Daten Messen, in der Entwicklung wurde eine Messung im Abstand
von 50ms, 100ms und 200ms festgestellt, kann die Mittelung auch über
einen gewissen Zeitwert vorgenommen werden.

#### Ausrichtung des Gerätes

Die Orientierung des Gerätes wird als „Portrait“ oder „Landscape“, also
vertikale oder horizontale Ausrichtung beschrieben. Diese Daten
verwenden dieselbe Technik wie der Beschleunigungssensor und wird
beispielsweise in der Bildschirmausrichtung verwendet. So einfach wie
das Prinzip ist auch die Verwendung: Die Ausrichtung lässt sich über
window.orientation; (in Grad) ausmessen. Ein Wert über 180 beschreibt
dabei den Portraitmodus, über 180 den Landscape- oder Landschaftsmodus.

#### Bild und Tonaufzeichungen

\
Da dies einer der komplexeren Datentypen ist, den man mit dem Handy
aufzeichnen kann, empfiehlt sich für die Aufnahme eine leicht benutzbare
API. Mit getUserMedia() ist für Bild und Ton nun eine einfache
Alternative verfügbar, die Stückweise in die aktuelle Browsergeneration
eingefügt wird. Die aktuelle Verfügbarkeit innerhalb der Browser kann
auf caniuse.com eingesehen werden und ergibt das Bild wie in Anhang
\[app:caniuseMedia\] aufgeziegt.

#### Vibration

Im Gegensatz zu den anderen Daten geht es hierbei nicht um eine Ein-,
sondern um eine Ausgabemethode. Die Benachrichtigung über Vibrationen
ist in JavaScript denkbar einfach gestaltet, ist aber, ebenso wie die
vorherigen APIs, nicht in jedem Browser verfügbar. Der letztliche Aufruf
der Funktion geschieht über den Navigator, explizit über
window.navigator.vibrate(), wobei die Länge und Art der Vibration
angegeben werden kann.

#### Browserempfehlung

Da (noch) nicht alle Browser alle APIs unterstützen, soll hier eine
Empfehlung zur Verwendung der oben genannten Funktionalitäten genannt
werden. Sowohl auf dem Desktop-Rechner als auch unter Android ist
derzeit die aktuelle Version von Firefox (43) am 15.12.2015 erschienen
und in der Lage, alle genannten Funktionen und APIs auszuführen.

Graphical User Interface and JavaScript
---------------------------------------

Den Kern der grafischen Oberfläche bilden zwei Pfeile, die nach dem
Prinzip eines Steuerkreuzes funktionieren und dazu genutzt werden, die
Geschehnisse auf dem verbundenen Rechner zu kontrollieren. Die
Benutzeroberfläche wurde absichtlich übersichtlich und simpel gehalten,
um eine schnelle Akzeptanz zu gewährleisten. Aus Test- und
Präsentationsgründen wurde in jeder Ecke des Templates eine Checkbox
platziert, die jeweils eine Art von Sensordaten steuert. Speziell die
gezielte Deaktivierung und Aktivierung der Audio- und Videodaten wurde
als wichtiges Kriterium angesehen, da dies einen gefährlichen Eingriff
in die Privatsphäre darstellen kann. Aus diesem Grund ist eine
Aktivierung der genannten Multimediadaten nicht ohne vorherige
Bestätigung möglich.\
Jeder Tastendruck wird vom dahinterliegenden JavaScript aufgefangen und
direkt an den Rechner weitergeleitet, wo er entsprechende Aktionen
auslöst. Um den Benutzer in der Bedienung Sicherheit zu geben, wird für
jeden Tastendruck ein optisches Feedback gegeben, entweder durch direkte
Aktionen auf dem Rechner oder als Hinweis auf dem Smartphone selbst.

Nutzen der GameAPI
------------------

Der Entwickler kopiert das in Anhang \[lst:CodeSnippetGameApi\]
kommentierte Code-Skelett in sein Spiel und füllt die gekennzeichneten
Stellen mit seiner Spielsteuerung.

Demonstration
=============

Vorbereitung
------------

Ein Computer stellt den NodeJS Server.\
Ein weiterer Computer stellt das gewählte Demogame-Frontend auf einem
großen Bildschirm dar.\
Mehrere Clients verbinden sich mit ihren mobilen Geräten auf den
Server.\
Anschließend müssen die vom NodeJS Server benötigten Abhgängikeiten
installiert werden. Dies geschieht mit einen Aufruf des Skriptes
“prepareDeps.sh”.

Start der Applikation
---------------------

Der NodeJS Server wird mit dem Befehl wie in Listing
\[lst:launchSuccess\] gestartet. Imfolgenden sollte eine Meldung
erscheinen welche den Applikationsserver als gestartet meldet. Eine
Beispielhafte Meldung in in Listing \[lst:launchSuccess\] zu sehen.

                node NodeServer/bin/www
                16 Jan 14:39:22 serverNetwork | Server listening on port 5222
            

Nutzen einer Demo Applikation
-----------------------------

\[t\]<span>0.4</span>

#### Controller Interface

\
Die Clients rufen die Adresse des Servers auf und es wird ihnen eine
Login Anzeige dargestellt. Hier wird nun eine Entscheidung getroffen, ob
ein Login erstellt, genutzt oder anonym weiter fortgefahren werden soll.
Wird ein Login genutzt, wird anstelle eines generierten Namens der
tatsächliche Benutzername im gewählten Demogame angezeigt.

\[t\]<span>0.5</span>

![Unterstützung der getUserMedia API auf caniuse.com<span
data-label="fig:test2"></span>](images/controllerLayoutModern){width="8cm"}

\[t\]<span>0.4</span>

#### Demo Applikation

\
Auf einem Browser, welcher als Frontend dient, muss nun das
entsprechende Game über die URL aufgerufen werden. In der
Demo-Applikation ist dies “/game/ 1|2|3 /” Die nun verbundenen Clients
führen mit ihren Geräten unterschiedliche Aktionen durch. Ein Druck auf
einen der Buttons auf einem der Clientgeräte wird als solcher
identifiziert und im Frontend dargestellt. Ein anderer Client aktiviert
die Rotationserfassung und die gesendeten Daten erscheinen auf dem
Fronend.

\[t\]<span>0.5</span>

![Unterstützung der getUserMedia API auf caniuse.com<span
data-label="fig:test2"></span>](images/demoGames){width="8cm"}

Lasttestmessung {#Lasttestmessung}
===============

Server
------

#### Szenario

Der Server wird nach und nach mit immer mehr Paketen belastet und die
CPU-Auslastung ermittelt.

#### Durchführung

\
Mithilfe des node-inspectors[^3] wurde die NodeJS-Serveranwendung
analysiert. Der node-inspector ermöglicht eine Nutzung der
Entwicklertools des Chrom-Browsers. Zur Ermittlung der CPU-Last wurden
Profile bei verschiedenen Lastzuständen erstellt welche 30 Sekunden lang
aufrecht erhalten wurden. Das Testsystem war dabei mit einem Intel(R)
Xeon(R) CPU E3-1241 v3 @ 3.50GHz ausgestattet.

\[t\]<span>0.4</span>

#### Ergebnisse

\
Anhand der Ergebnisse ist gut der lineare Anstieg der Auslastung zu
erkennen. Das Diagramm \[fig:ServerLast2\] stellt die Ergebnisse von 0
bis 5500 Paketen da. Auf dem Diagramm \[fig:ServerLast2\] ist gut zu
erkennen das die Auslastung ab circa 3500 Paketen in einem geringerem
maße ansteigt, allerdings ist auch hier ein linearer Verlauf zu
erkennen. Die Auslastung schwankt zwar je nach eingesetzten System, der
lineare Anstieg wird sich übertragen lassen. Um dies zu bestätigen sind
weitere Messungen auf verschiedenen Testsystemen nötig.

\[t\]<span>0.5</span>

![Serverlast bei 0 - 5500 Paketen<span
data-label="fig:ServerLast2"></span>](./images/ServerLast3.png){width="100.00000%"}

### Frontend

#### Test Szenario

Zur Messung der Latenz wird ein Gerät mit dem Server verbunden und jede
Sekunde dessen durchschnittliche Latenz vom Senden der Daten auf dem
Gerät bis zur Ausgabe dieser durch die API erfasst. Die Auslastung des
Servers wird durch das Senden von zusätzlichen Paketen erreicht. Die
Senderate wird nach und nach gesteigert um die Maximale Auslastung der
API auf dem Testsystem zu ermitteln. Zu beachten ist das auf allen
Geräten vergleichbare Zeitstempel vergeben werden um die Ergebnisse
nicht zu verfälschen. Die Test werden dabei ohne die Anbindung einer
Anwendung an die API durchgeführt. Zu beachten ist, das diese auch
Leistung benötigt was die Ergebnisse drastisch verändern kann. Aufgrund
des Fokus auf die Entwicklung einer API ohne eine gezielte Anwendung
wurde diese nicht berücksichtigt.

#### Durchführung

Zur Erfassung der Daten wurde die Anzahl der gesendeten Pakete und der
durchschnittlichen Latenz pro Sekunde von einem Gerät ermittelt. Während
der Messung wurde der Server mit einer Unterschiedlich starken Anzahl an
zusätzliche Paketen belastet um eine Höhere Auslastung zu erreichen. Die
Werte wurden dabei in einem Abstand von einer Sekunde ermittelt. Zum
Erfassen er Daten wurden die Chrome-Entwicklertools verwendet. Es wurden
für jede Laststufe Daten über 50 Sekunden erfasst. Der Server und das
Frontend liefen bei dem Test auf dem gleichen System.

\[t\]<span>0.4</span>

#### Ergebnisse

\
Die Ergebnisse der Messung sind in dem Diagramm \[fig:LatenzMessung\] zu
erkennen. Der Mittelwert gibt die Durchschnittliche Latenz über 50
Sekunden an. Durch die mittlere Abweichung ist gut zu erkennen das es zu
gelegentlichen Latenz Spitzen kommt, welche im Betrieb unter Umständen
zu Problemen führen können. Ab einer Paketanzahl von 5000 ist ein
drastischer Anstieg der durchschnittlichen Latenz zu erkennen. Bei der
Annahme das ein Gerät  100 Pakete die Sekunde versenden kann, kann im
Betrieb ohne Anwendung eine auf dem Testsystem maximal mögliche Anzahl
von 50 Geräten angenommen werden. Mit blick auf die Daten von der
Server-Leistungsmessung\[fig:ServerLast2\] sollte die Anzahl von 35
Geräten nicht überschritten werden und der Bereich von 35-50 Als
Pufferzone eingeplant werden.

\[t\]<span>0.5</span>

![Geräte Latenz Messung<span
data-label="fig:LatenzMessung"></span>](./images/LatenzMessung.png){width="100.00000%"}

Ausblick
========

#### QRCode

Busstop sinnvoll, gameApi.printQRCode()

#### Glättung der Sensor Werte

Ein noch zu lösendes Problem ist die Glättung der von den Sensoren
kommenden Werte. Je nach Gerät liefern die Sensoren unterschiedlich
Stark schwankenden Daten. So feuert ein auf dem Tisch liegendes Gerät
permanent Orientierungsdaten, obwohl es nicht bewegt wird. Diese
Schwankungen müssen erkannt und unterbunden werden. Einbauen eines
thresholds.

#### Begrenzung der gesendeten Sensor Daten

Um den Server nicht ungleich durch die verschiedenen Geräte zu belasten
und die Auslastung berechenbar zu machen, muss das Sendeverhalten
reglementiert werden. Die optimalen Werte dafür müssen noch durch
weitere Leistungstest ermittelt werden und hängen auch von der Anwendung
ab welche an die API angebunden ist.

Fazit
=====

Die Umsetzung zeigt ein flexibles und belastbares Framework, welches es
ermöglicht ein Spiel unkompliziert mit einem mobilen Gerät zu bedienen.
Ein Spieleentwickler hat die Möglichkeit eigene Controller-Templates
bereitzustellen und mühelos sein Spiel zu integrieren. Dazu nutzt er den
Beispielcode und bedient sich der Eingabeevents des Frameworks, welche
generiert werden. Das Usermanagement ermöglicht zudem eine komfortable
Individualisierung der Spieler.

\[lst:CodeSnippetGameApi\]

        /** gameApi.controllerTemplates.*
        * Hier traegt der Entwickler ein, welches Gamepad-Controller Layout
        * auf dem Smartphone des Spielers angezeigt werden soll
        * */
        gameApi.controller = gameApi.controllerTemplates.MODERN;
        /**
         * HANDSHAKE - bitte nicht modifizieren
         * */
        gameApi.frontendConnection = function (connInfoObj) {
            gameApi.addLogMessage(gameApi.log.INFO, 'conn', connInfoObj + " " + gameApi.socket.id);
            this.emit('frontendOutboundMessage', {type: 'setControllerTemplate', data: gameApi.controller});
        };

        /**
         * Handling der eingehenden Daten
         * Hier wird die Steuerung des Spiels mit den Steuerungsdaten vom Smartphone kombiniert
         * */
        gameApi.frontendInboundMessage = function (data) {
            var controllerEvent = controllerData.data.message;
            var clientName = data.data.clientName;
            var message = data.data.message;

            switch (data.type) {
                // Ein Client betritt oder verlaesst das Spiel
                case "userConnection":
                    gameApi.addLogMessage(gameApi.log.INFO, 'client', 'Client ' + clientName + ' ' + message);

                    if (message === 'connected') {
                        // Was soll passieren wenn sich ein Client ins Spiel einloggt
                    } else if (message === 'disconnected') {
                        // Was soll passieren, wenn sich ein Client das Spiel verlaesst
                    }
                    break;
                // Ein Client sendet ein Button Event
                case "button":
                    if (controllerEvent.buttonName == 'btn-left' && controllerEvent.buttonState === gameApi.BUTTON.DOWN) {
                        // Was soll passieren, wenn Button A gedrueckt wird
                    } else if (controllerEvent.buttonName == 'btn-right' && controllerEvent.buttonState === gameApi.BUTTON.DOWN) {
                        // Was soll passieren, wenn Button B gedrueckt wird
                    }
                    break;
                case "accelerationData":
                    //Was passiert mit den Beschleunigungsdaten?
                    break;
                case "orientationData":
                    //Was passiert mit den Rotationsdaten?
                    break;
                default:
                    break;
            }
            

![3D-Cube<span
data-label="3dcube"></span>](images/FrontendInit){width="100.00000%"}

![m113<span
data-label="m113"></span>](images/arch/M113.png){width="100.00000%"}

![Rotationsachen dargestellt<span
data-label="app:caniuseMedia"></span>](images/caniuseGetUserMedia)

![Rotationsachen dargestellt<span
data-label="rotation"></span>](images/rotation){width="100.00000%"}

![ServerLast 0 - 10 Pakete<span
data-label="serverlast1"></span>](images/ServerLast1.png){width="100.00000%"}

![ServerLast 10 - 100 Pakete<span
data-label="serverlast1-2"></span>](images/ServerLast2.png){width="100.00000%"}

![ServerLast 0 - 55000 Pakete<span
data-label="serverlast2"></span>](images/ServerLast3.png){width="100.00000%"}

![Latenzmessung<span
data-label="latenzmessung"></span>](images/LatenzMessung.png){width="100.00000%"}

[^1]: <https://davidwalsh.name/websocket> \[3\] \[4\]

[^2]: <http://de.slideshare.net/DamianGordon1/3d-robot-movements>

[^3]: https://github.com/node-inspector/node-inspector
